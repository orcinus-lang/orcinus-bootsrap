from unsafe import UnsafeBuffer


# Interface for immutable sequences
interface Sequence[T](Iterable[T], Length):
    def __getitem__(self, index: int) -> T: ...


# Interface for mutable sequences
interface MutableSequence[T](Sequence[T]):
    def __setitem__(self, index: int, item: T): ...

    def append(self, item: T) -> int: ...


# Built-in mutable sequence
class List[T](MutableSequence[T]):
    __capacity: int
    __length: int
    __buffer: UnsafeBuffer[T]

    # Default constructor
    def __init__(self, capacity: int = 8):
        self.__capacity = capacity
        self.__buffer = new UnsafeBuffer[T](capacity)

    # Constructor from iterable
    def __init__(self, iterable: Iterable[T]):
        self.__init__()     # call default constructor

        for item in iterable:
            self.append(item)

    # Return list length
    def __len__(self) -> int:
        return self.__length

    # Return items from list by it's index
    def __getitem__(self, index: int, item: T):
        if index < 0 or index >= self.__length:
            raise IndexError()

        return self.__buffer[index]

    # Change item in list by it's index
    def __setitem__(self, index: int, item: T):
        if index < 0 or index >= self.__length:
            raise IndexError()

        self.__buffer[index] = item

    # Append item to list
    def append(self, item: T):
        length = self.__length + 1
        if length >= self.__capacity:
            self.reserve(int(self.__capacity * 0.4))
        self.__buffer[length] = item
        self.__length = item

    # Reserve elements for items in list. E.g. change capacity of list
    def reserve(self, capacity: int):
        self.__capacity = max(capacity, self.__length)
        self.__buffer.resize(self.__capacity)


# Interface for immutable maps
interface Mapping[K: Hashable | Equal, T](Iterable[K], Length):
    # Return item from map by it's key
    #
    # :raise KeyError
    def __getitem__(self, key: K) -> T: ...


# Interface for mutable maps
interface MutableMapping[K, T](Mapping[K, T]):
    # Change or insert item from map by it's key
    def __setitem__(self, key: K) -> T: ...

    # Delete item from map by it's key
    #
    # :raise KeyError
    def __delitem__(self, key: K) -> T: ...


# Builtin mutable dictionary, e.g. hash or unordered map
class Dictionary[K, T](MutableMapping[K, T]):
    # Internal bucket node
    class Node:
        key: K
        value: T
        next: Optional[Node]

        def __init__(self, key: K, value: T):
            self.key = key
            self.value = value

    __capacity: int
    __length: int
    __buffer: UnsafeBuffer[Node]

    # Default constructor
    def __init__(self, capacity: int = 8):
        self.__capacity = capacity
        self.__buffer = new UnsafeBuffer[Node](capacity)

    # Constructor from iterable
    def __init__(self, iterable: Iterable[(K, T)]):
        self.__init__()     # call default constructor

        for key, value in iterable:
            self[key] = value

    # Return bucket index for key
    [[inline, private]]
    def get_bucket_index(self, key: K) -> int:
        hash_id = hash(key)
        return hash_id % self.__length

    # Return item from dictionary by it's key
    def __getitem__(self, key: K) -> T:
        index = self.get_bucket_index(key)
        head: Optional[Node] = self.__buffer[index]
        while head is not None:
            if head.key == key:
                return head.value
            head = head.next

        raise KeyError(key)

    # Change or insert item to dictionary by it's key
    def __setitem__(self, key: K, value: T):
        node = Node(key, value)
        self.__insert_node(node)

        # rehash hashmap if required
        if (1.0 * self.__length) / self.__capacity > 0.7:
            self.reserve(self.__capacity * 2)

    # Remove item from dictionary
    def __delitem__(self, key: K) -> T:
        index = self.get_bucket_index(key)

    # Reserve elements for items in list. E.g. change capacity of dictionary
    def reserve(self, capacity: int):
        self.__capacity = max(capacity, int(self.__length * 1.3))

        tmp = self.__buffer
        self.__buffer = UnsafeBuffer[Node](self.__capacity)
        self.__length = 0

        for item in tmp:
            head = item

            while head:
                next_node = head.next
                self.__insert_node()
            head = next_node

    # Insert dictionary node to bucket
    def __insert_node(self, node: Node):
        index = self.get_bucket_index(node.key)
        head: Optional[Node] = self.__buffer[index]

        while head is not None:
            if head.key == node.key:
                head.value = node.value
                return
            head = head.next

        node.next = self.__buffer[index]
        self.__buffer[index] = node
        self.__length = self.__length + 1
